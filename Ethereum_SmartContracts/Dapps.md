# Ethereum: Distributed Applications (Dapps)

# Architecture
Dapps usually consist of a front- and a back-end architecture with interactions with a smart contract (SC) on the blockchain. The fornt end is outside of the blockchain, but it commiunicates with the SC via artefacts generated by the complier. The back-end may or may not be on the blockchain. The front-end may be anything form a Command Line Interface (CLI) to a mobile app on a smartphone.


## Ethereum Blockchain Server
The high-level Dapps Stack looks as follows:
1. End User Applications
2. Smart Contracts
3. Ethereum Blockchain and EVM
4. P2P-Network and OS
5. Hardware
The Blockchain Server entails the infrastructure and the functionality that the blockchain provides.

## Truffle IDE

The general process of migrating a SC to a (test) chain is as follows:
1. Init and Edit SC
2. Compile SC
3. Create local test Blockchain
4. Configure Truffle Environment
5. Migration to test Blockchain

### Init & Edit
Create a new workspace *$ cd* to the workspace and execute *$ truffle init*, which crates a template for a Dapp. This creates three folders:
1. contracts: containing Solidity source files for SCs
2. migrations: facilitates contract deployments
3. test: contains JavaScript and Solidity tests for SCs, Truffle config file (Node Address, RPC Port)
Copy the SCs under developmen to the contracts folder by using *$ cp SOURCE DEST*. The  text editor of choice is the gedit editor e.g. doing *$ gedit contracts/Ballot.sol &*


### Compiler
To compile move to the workspace folder make sure you have SCs source code in the contracts folder. You are now ready to execute *$ truffle compile*, which creates the build artifacts in a separate folder called build. Remix IDE which a just-in-time Compiler, which is able to spot syntax errors as you code. In contrast Truffle IDE only shows syntax errors upon compilation.
Configuration of the Truffle Environment now required to target the local Blockchain Server. To do so populate the truffle.js file with a code similar to this:
~~~
module.exports = {
 networks:{
 development:{
  host:"localhost",
  port: 9545, // RBC Port for test chain
  network_id:"*" // * = any network id 
 }
 }
};
~~~
This connects to the Blockchain that is deployed in the next section.

### Setup Local Test Blockchain
In a new command window navigate to the workspace folder and deploy the test Blockchain using *$ truffle develop*. This deploys a local test Blockchain with 10 Account addresses ready for development. Take note of the seed (Mnemonic) by noting it for later use.
In the migrations directory add a new file named 2_deploy_contracts.js and add the following piece of code:
~~~
var Ballot = artifacts.require("Ballot");
 module.exports = function(deployer){
  deployer.deploy(Ballot);
 };
~~~

### Smart Contract Deployment
The command *$ truffle migrate --reset* will migrate the SC and the aritfacts to the local Blockchain. In essence this just runs all the .js files in the migration folder. The *--reset* option makes sure any old versions of the SC on the Blockchain is updated with the new one. Note once the SC has been deployed to the Blockchain it cannot be updated anymore. however, escape hatches offer a solution to this.

### Truffle Console
Truffle Console Creates a commandline interface to the accounts crreated on the test Blockchain and to the managment APIs. Examples:
Sending Coins:
~~~
web3.eth.sendTransaction({from:web3.eth.coinbase,to:web3.eth.accounts[1],value: 99})
~~~
Get Balance:
~~~
web3.eth.getBalance(from:web3.eth.coinbase)
~~~
Get Balance:
~~~
web3.eth.getBalance(from:web3.eth.coinbase)
web3.eth.getBalance(from:web3.eth.coinbase).toNumber()
~~~

## Test Driven Development
In general tests performed can be categorized into two sub-categories:
1. Positive Test: Based on valid input, regular behavior is expected
2. Negative Test: Based on invalid input, error capture is expected
Usually the tester ist written in the same language as the Programm to be tested. However, this may not be feasibilbe for SCs that depend on who sends the message to the contract. In such cases a SC cannot be testeb by another SC you have to resort to JavaScript. 

Testing in Truffle IDE based on the test blockain as described above reuires as test script test.js in the test directory. From the base dir run Truffle command *truffle test*.

## Adding Front-End
The web assets are stored in src folder in the workspace. In particular the app.js file initializes the Web3 Object. The App ist the receiver of all blockchain requestes, which passes these requests to the blockchain's RPC endpoint opened above. In addition to the Web3 component the app.js also intializes the conttract  component which points to the artifacts created in the compilation process. To make functions provided by the SC available to the front-end a handle function needs to be provided. To setup a light-weight development server run the following:
~~~
npm run dev
~~~
## Design Best Practices
### Solidity Features
Memory vs. Storage 
Data like Stuct and Arrays that are of temporary use can be stored as memory instead of storage like this:
~~~
address[30] memory owner = ... ;
~~~
Wihtout the *memory* keyword owner would be treated as storage and therefore woul be consume permanent sotorage on the blockchain.

Life time management
Killing or shuting down a deployed smart contract is possible by using the Solidity *self-destruct* feature. Caution the command is irreversible.

Inheritance
Inheritance from othe SCs works as follows:
~~~
contract FedLaws {} // in file FedLaws.sol
contract StateLaws {} // in file StateLaws.sol

import "FederalLaws.sol";
import "StatLaws.sol";
contract FieldLaws is FederalLaws, StateLaws {}
~~~
Libraries can be included this way into an SC.
    
###  Event Handling
Push notifications
Loging activities
Enables asynchronous operation

2. Logging events on the blockchain is recommended for notification purposes
3. A smart contract cannot access information outside the blockchain 

### Acessing Off-Chain Resources with Oraclize
Since the blockchain has to remain in cosistent state. The result of an action has to be deterministic. Thus, a smart contract cannot directly access external resources. Instead the SC need to use the Oraclize SC.
Oraclize serves as a data carrier between an on-chain SC and an off-chain web resources (APIs, URLs, ...). Oraclize facilitates the availability of real world facts for an SC, by providing a query function to external sources. The Oraclize SC fetches the data and provides authentication and proof of the source. The result of the query is provided in a callback function, as the fetching process may need some time. 
This is how usingOraclize used?
~~~
import "../usingOraclize.sol"

contract AvgWinterTemp is usingOraclize {} // AvgWinterTemp inherits from usingOraclize the fucntions to acces external resources
~~~
More information on Oraclize is available here: [Getting data from the internet with Oraclize](https://ethereumdev.io/getting-data-internet-oraclize/)

## Dapp Models
Check [www.stateofthedapps.com](https://www.stateofthedapps.com) to find a broad range of Dapps.

## Dapp Standards
ERC 20 and ERC 721
On Ethereum blockchain standards are implemented by having standardized processes for all kinds of matters. A prominent example of a standard is:
1. [EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md) (Ethereum Improvement Proposal) having the following subclasses
 1.1 Core: Core Ethereum protocol
 1.2 Network: Network level improvement
 1.3 Interface: Interfaces such as ABI, RPC
 1.4 ERC (Ethereum Request for Comments): Application level conventions and standards (e.g. ERC N, discussed on github)
  1.5 [ERC 20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md): making self coined tokens ERC 20 compliant. Implementation:
  ~~~
  contract MyToken is ERC20Interface{
	//implement functions required by ERC20Interface standard
	//implement own functions
  }
  ~~~
  1.6 [ERC 721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md): standard for non-fungible tokens. The concept of fungibility is important to tokens. Fungible tokens can be exchange one for anoter 1$ Bill = 1$ Bill. But a 1 Penny coin is not 1:1 exchangeable to collector edition 1 Penny coin and therefore the collector edition 1 Penny coin is non-fungible. The standard example for non-fungible tokens are CryptoKitties.
 
 





