# Ethereum: Distributed Applications (Dapps)
<<<<<<< HEAD
# Architecture
Dapps usually consist of a front- and a back-end architecture with interactions with a smart contract (SC) on the blockchain. The fornt end is outside of the blockchain, but it commiunicates with the SC via artefacts generated by the complier. The back-end may or may not be on the blockchain. The front-end may be anything form a Command Line Interface (CLI) to a mobile app on a smartphone.
=======
## Architecture
Dapps usually consist of a front- and a back-end architecture with interactions with a smart contract (SC) on the blockchain. The front end is outside of the blockchain, but it communicates with the SC via artefacts generated by the complier. The back-end may or may not be on the blockchain. The front-end may be anything form a Command Line Interface (CLI) to a mobile app on a smartphone.
>>>>>>> e8165e853945708162eef81cb5659d4f06990774

## Ethereum Blockchain Server
The high-level Dapps Stack looks as follows:
1. End User Applications
2. Smart Contracts
3. Ethereum Blockchain and EVM
4. P2P-Network and OS
5. Hardware
The Blockchain Server entails the infrastructure and the functionality that the blockchain provides.

## Truffle IDE

The general process of migrating a SC to a (test) chain is as follows:
1. Init and Edit SC
2. Compile SC
3. Create local test Blockchain
4. Configure Truffle Environment
5. Migration to test Blockchain

### Init & Edit
Create a new workspace *$ cd* to the workspace and execute *$ truffle init*, which crates a template for a Dapp. This creates three folders:
1. contracts: containing Solidity source files for SCs
2. migrations: facilitates contract deployments
3. test: contains JavaScript and Solidity tests for SCs, Truffle config file (Node Address, RPC Port)
The editor of choice is the gedit editor e.g. doing *$ gedit contracts/Ballot.sol &* 


### Compiler
To compile move to the workspace folder make sure you have SCs source code in the contracts folder. You are now ready to execute *$ truffle compile*, which creates the build artifacts in a separate folder called build. Remix IDE which a just-in-time Compiler, which is able to spot syntax errors as you code. In contrast Truffle IDE only shows syntax errors upon compilation.
Configuration of the Truffle Environment now required to target the local Blockchain Server. To do so populate the truffle.js file with a code similar to this:
~~~
module.exports = {
 networks:{
 development:{
  host:"localhost",
  port: 9545, // RBC Port for test chain
  network_id:"*" // * = any network id 
 }
 }
};
~~~
This connects to the Blockchain that is deployed in the next section.

### Setup Local Test Blockchain
In a new command window navigate to the workspace folder and deploy the test Blockchain using *$ truffle develop*. This deploys a local test Blockchain with 10 Account addresses ready for development. Take note of the seed (Mnemonic) by noting it for later use.
In the migrations directory add a new file named 2_deploy_contracts.js and add the following piece of code:
~~~
var Ballot = artifacts.require("Ballot");
 module.exports = function(deployer){
  deployer.deploy(Ballot);
 };
~~~

### Smart Contract Deployment
The command *$ truffle migrate --reset* will migrate the SC and the aritfacts to the local Blockchain. The *--reset* option makes sure any old versions of the SC on the Blockchain is updated with the new one. Note once the SC has been deployed to the Blockchain it cannot be updated anymore. however, escape hatches offer a solution to this.

### Truffle Console
Truffle Console Creates a commandline interface to the accounts crreated on the test Blockchain and to the managment APIs. Examples:
Sending Coins:
~~~
web3.eth.sendTransaction({from:web3.eth.coinbase,to:web3.eth.accounts[1],value: 99})
~~~
Get Balance:
~~~
web3.eth.getBalance(from:web3.eth.coinbase)
~~~
Get Balance:
~~~
web3.eth.getBalance(from:web3.eth.coinbase)
web3.eth.getBalance(from:web3.eth.coinbase).toNumber()
~~~

## Test Driven Development
In general tests performed can be categorized into two sub-categories:
1. Positive Test: Based on valid input, regular behavior is expected
2. Negative Test: Based on invalid input, error capture is expected
Usually the tester ist written in the same language as the Programm to be tested. However, this may not be feasibilbe for SCs that depend on who sends the message to the contract. In such cases a SC cannot be testeb by another SC you have to resort to JavaScript. 
